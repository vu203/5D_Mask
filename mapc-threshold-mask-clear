#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Tue Feb 21 10:54:13 2017

@author: Lab
"""

# 
# % reset

""" --------------- IMPORT REQUIRED PACKAGES ---------------    

For working with images:
  - numpy to hold image data as np arrays
  - skimage to import tiff files as multi-dimensional arrays
  - scipy.ndimage for LoG 
  - mahotas for fast image manipulation (C++ based)
  - pylab for image display      
"""

import matplotlib
import numpy as np
import mahotas as mh
import pylab

from pylab import imshow
# from pylab import show
# import scipy.ndimage as nd
import skimage
# from skimage import io
from skimage import morphology
#from scipy.ndimage import gaussian_laplace

import tifffile as tiff
# use TiffFile object

# pwd
# cd ..
#cd image_processing
pwd
ls






""" --------------- READ IMAGE FILES --------------- 

Tiff stacks as multi-dimensional stacks
"""

# gcio = io.imread('growthcone2C1T.tif')
# image = tf.imread('growthcone2C1T.tif')

with tiff.TiffFile('growthcone2C1T.tif') as tif:
    image = tif.asarray()
#    for page in tif:
#        for tag in page.tags.values():
#            t = tag.name, tag.value
#        image = page.asarray()

imshow(image[0])

pylab.jet()
pylab.hot()

mapc = image[0]
signalc = image[1]

""" --------------- THRESHOLDING --------------- 
Use simple otsu thresholding method to create binary mask
"""

#mapc_LoG = gaussian_laplace(signalc, 2.6*0.065)
imshow(mapc)
#imshow(mapc_LoG)

# th1 = mh.thresholding.otsu(mapc)
th1 = skimage.filters.thresholding.triangle(mapc)
#th2 = mh.thresholding.otsu(mapc_LoG)
print th1
#print th2

imshow(mapc > th1)
#imshow(mapc_LoG > th2)

mask = (mapc > th1) # mask is a boolean matrix
print mask
print mask[:12, :12] # displaying corner values
print mask[230:240, 230:240] # displaying centre values

""" def FillHoles(mask_in): """ # need to add fill holes eventually! 

""" --------------- DILATION --------------- 
Dilate binary mask by a set number of pixels
"""

def multiDilate(binary_input, steps):
    curr_image = binary_input
    for i in range(steps):
        curr_image = skimage.morphology.binary_dilation(curr_image)
    return curr_image
        
#mask3 = multiDilate(mask, 3)
#imshow(mask3)
#imshow(mask)
#imshow(mask3 - mask)

mask_dil = multiDilate(mask, 5)

# Displaying masked vs unmasked signal channel:
imshow(signalc * mask_dil)
imshow(signalc)
imshow(mask_dil - mask)

signal_filt = signalc * mask_dil

""" --------------- WRITE A FILTERED FILE ---------------
Dilate binary mask by a set number of pixels
"""

image[1] = signal_filt
tiff.imsave("test.tif", image) # does not preserve metadata!

